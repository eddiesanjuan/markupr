/**
 * MarkdownGenerator Expanded Tests
 *
 * Tests the markdown output generation with focus on:
 * - PostProcess output format (generateFromPostProcess)
 * - Timestamp formatting
 * - Frame-to-segment mapping
 * - Various input combinations (segments only, frames only, both, empty)
 * - Heading structure
 */

import { describe, it, expect, beforeEach } from 'vitest';
import {
  MarkdownGenerator,
  type Session,
  type GenerateOptions,
} from '../../src/main/output/MarkdownGenerator';
import type { PostProcessResult, TranscriptSegment, ExtractedFrame } from '../../src/main/pipeline/PostProcessor';

// =============================================================================
// Tests
// =============================================================================

describe('MarkdownGenerator (expanded)', () => {
  let generator: MarkdownGenerator;

  beforeEach(() => {
    generator = new MarkdownGenerator();
  });

  describe('generateFromPostProcess', () => {
    it('should generate markdown header with session timestamp', () => {
      const result: PostProcessResult = {
        transcriptSegments: [
          { text: 'Hello world.', startTime: 0, endTime: 5, confidence: 0.95 },
        ],
        extractedFrames: [],
        reportPath: '/tmp/report.md',
      };

      const md = generator.generateFromPostProcess(result, '/tmp/session');

      expect(md).toContain('# markupR Session');
      expect(md).toContain('## Transcript');
    });

    it('should handle empty transcription', () => {
      const result: PostProcessResult = {
        transcriptSegments: [],
        extractedFrames: [],
        reportPath: '/tmp/report.md',
      };

      const md = generator.generateFromPostProcess(result, '/tmp/session');

      expect(md).toContain('_No speech was detected during this recording._');
      expect(md).not.toContain('## Transcript');
    });

    it('should format transcript segments with timestamps', () => {
      const result: PostProcessResult = {
        transcriptSegments: [
          { text: 'First segment about the button.', startTime: 0, endTime: 5, confidence: 0.9 },
          { text: 'Second segment about the nav.', startTime: 15.3, endTime: 20, confidence: 0.88 },
        ],
        extractedFrames: [],
        reportPath: '/tmp/report.md',
      };

      const md = generator.generateFromPostProcess(result, '/tmp/session');

      expect(md).toContain('[0:00]');
      expect(md).toContain('[0:15]');
      expect(md).toContain('> First segment about the button.');
      expect(md).toContain('> Second segment about the nav.');
    });

    it('should format timestamps correctly for minutes', () => {
      const result: PostProcessResult = {
        transcriptSegments: [
          { text: 'Later segment.', startTime: 125, endTime: 130, confidence: 0.9 },
        ],
        extractedFrames: [],
        reportPath: '/tmp/report.md',
      };

      const md = generator.generateFromPostProcess(result, '/tmp/session');

      expect(md).toContain('[2:05]');
    });

    it('should include frame references associated with segments', () => {
      const result: PostProcessResult = {
        transcriptSegments: [
          { text: 'The button is broken.', startTime: 0, endTime: 10, confidence: 0.9 },
        ],
        extractedFrames: [
          {
            path: '/tmp/session/screenshots/frame-001.png',
            timestamp: 5,
            reason: 'Key moment detected',
          },
        ],
        reportPath: '/tmp/report.md',
      };

      const md = generator.generateFromPostProcess(result, '/tmp/session');

      expect(md).toContain('![Frame at 0:05]');
      expect(md).toContain('screenshots/frame-001.png');
    });

    it('should handle frames with relative paths', () => {
      const result: PostProcessResult = {
        transcriptSegments: [
          { text: 'Test.', startTime: 0, endTime: 5, confidence: 0.9 },
        ],
        extractedFrames: [
          {
            path: 'screenshots/frame-001.png',
            timestamp: 2,
            reason: 'Key moment',
          },
        ],
        reportPath: '/tmp/report.md',
      };

      const md = generator.generateFromPostProcess(result, '/tmp/session');

      expect(md).toContain('![Frame at 0:02](screenshots/frame-001.png)');
    });

    it('should include footer with markupR branding', () => {
      const result: PostProcessResult = {
        transcriptSegments: [
          { text: 'Content here.', startTime: 0, endTime: 5, confidence: 0.9 },
        ],
        extractedFrames: [],
        reportPath: '/tmp/report.md',
      };

      const md = generator.generateFromPostProcess(result, '/tmp/session');

      expect(md).toContain('Generated by [markupR]');
    });

    it('should map frames to the closest segment by time', () => {
      const result: PostProcessResult = {
        transcriptSegments: [
          { text: 'First topic.', startTime: 0, endTime: 10, confidence: 0.9 },
          { text: 'Second topic.', startTime: 20, endTime: 30, confidence: 0.9 },
        ],
        extractedFrames: [
          { path: '/tmp/session/screenshots/frame-001.png', timestamp: 25, reason: 'Key moment' },
        ],
        reportPath: '/tmp/report.md',
      };

      const md = generator.generateFromPostProcess(result, '/tmp/session');

      // The frame at t=25 should appear after the second segment (20-30)
      const secondSegmentPos = md.indexOf('Second topic');
      const framePos = md.indexOf('frame-001.png');
      expect(framePos).toBeGreaterThan(secondSegmentPos);
    });

    it('should handle both segments and multiple frames', () => {
      const result: PostProcessResult = {
        transcriptSegments: [
          { text: 'Segment one.', startTime: 0, endTime: 10, confidence: 0.9 },
          { text: 'Segment two.', startTime: 15, endTime: 25, confidence: 0.9 },
        ],
        extractedFrames: [
          { path: '/tmp/session/screenshots/frame-001.png', timestamp: 5, reason: 'Heuristic' },
          { path: '/tmp/session/screenshots/frame-002.png', timestamp: 20, reason: 'AI hint' },
        ],
        reportPath: '/tmp/report.md',
      };

      const md = generator.generateFromPostProcess(result, '/tmp/session');

      expect(md).toContain('frame-001.png');
      expect(md).toContain('frame-002.png');
    });

    it('should handle frames-only (no segments)', () => {
      const result: PostProcessResult = {
        transcriptSegments: [],
        extractedFrames: [
          { path: 'screenshots/frame-001.png', timestamp: 5, reason: 'Timer' },
        ],
        reportPath: '/tmp/report.md',
      };

      const md = generator.generateFromPostProcess(result, '/tmp/session');

      // When no segments, it should show the "no speech detected" message
      expect(md).toContain('_No speech was detected');
    });
  });

  describe('generateFullDocument heading structure', () => {
    const baseSession: Session = {
      id: 'test-session-heading',
      startTime: new Date('2024-06-15T10:00:00').getTime(),
      endTime: new Date('2024-06-15T10:05:00').getTime(),
      feedbackItems: [
        {
          id: 'item-1',
          transcription: 'The submit button does not work correctly.',
          timestamp: new Date('2024-06-15T10:01:00').getTime(),
          screenshots: [],
          category: 'Bug',
        },
      ],
      metadata: {
        os: 'darwin',
        sourceName: 'TestApp',
        sourceType: 'window',
      },
    };

    const defaultOptions: GenerateOptions = {
      projectName: 'HeadingTest',
      screenshotDir: './screenshots',
    };

    it('should have H1 title', () => {
      const result = generator.generateFullDocument(baseSession, defaultOptions);
      expect(result.content).toMatch(/^# HeadingTest Feedback Report/m);
    });

    it('should have H2 sections for overview, summary, and feedback', () => {
      const result = generator.generateFullDocument(baseSession, defaultOptions);

      expect(result.content).toContain('## Session Overview');
      expect(result.content).toContain('## Executive Summary');
      expect(result.content).toContain('## Actionable Feedback');
      expect(result.content).toContain('## Summary');
    });

    it('should have H3 for individual feedback items', () => {
      const result = generator.generateFullDocument(baseSession, defaultOptions);
      expect(result.content).toContain('### FB-001:');
    });

    it('should have H4 subsections within feedback items', () => {
      const result = generator.generateFullDocument(baseSession, defaultOptions);
      expect(result.content).toContain('#### What Happened');
      expect(result.content).toContain('#### Evidence');
      expect(result.content).toContain('#### Suggested Next Step');
    });
  });

  describe('generateFullDocument with various inputs', () => {
    const defaultOptions: GenerateOptions = {
      projectName: 'TestProject',
      screenshotDir: './screenshots',
    };

    it('should handle single item with no screenshots', () => {
      const session: Session = {
        id: 'single-no-ss',
        startTime: Date.now() - 60000,
        endTime: Date.now(),
        feedbackItems: [
          {
            id: 'item-1',
            transcription: 'Simple feedback without screenshot.',
            timestamp: Date.now() - 30000,
            screenshots: [],
          },
        ],
      };

      const result = generator.generateFullDocument(session, defaultOptions);

      expect(result.content).toContain('FB-001');
      expect(result.content).toContain('_No screenshot captured for this item._');
      expect(result.metadata.itemCount).toBe(1);
      expect(result.metadata.screenshotCount).toBe(0);
    });

    it('should handle multiple items with mixed screenshots', () => {
      const now = Date.now();
      const session: Session = {
        id: 'mixed-session',
        startTime: now - 120000,
        endTime: now,
        feedbackItems: [
          {
            id: 'item-1',
            transcription: 'Item with screenshot.',
            timestamp: now - 90000,
            screenshots: [
              { id: 'ss-1', timestamp: now - 85000, imagePath: '/tmp/ss1.png', width: 1920, height: 1080 },
            ],
            category: 'Bug',
          },
          {
            id: 'item-2',
            transcription: 'Item without screenshot.',
            timestamp: now - 60000,
            screenshots: [],
            category: 'Suggestion',
          },
        ],
      };

      const result = generator.generateFullDocument(session, defaultOptions);

      expect(result.content).toContain('FB-001');
      expect(result.content).toContain('FB-002');
      expect(result.metadata.itemCount).toBe(2);
      expect(result.metadata.screenshotCount).toBe(1);
    });

    it('should handle session without metadata', () => {
      const session: Session = {
        id: 'no-metadata',
        startTime: Date.now() - 60000,
        endTime: Date.now(),
        feedbackItems: [
          {
            id: 'item-1',
            transcription: 'Test.',
            timestamp: Date.now() - 30000,
            screenshots: [],
          },
        ],
      };

      const result = generator.generateFullDocument(session, defaultOptions);

      expect(result.content).toContain('Unknown');
    });

    it('should handle session without endTime (in progress)', () => {
      const session: Session = {
        id: 'in-progress',
        startTime: Date.now() - 60000,
        feedbackItems: [],
      };

      const result = generator.generateFullDocument(session, defaultOptions);

      expect(result.content).toContain('_No feedback items were captured');
      expect(result.metadata.duration).toBe(0);
    });
  });

  describe('generateFeedbackItemId', () => {
    it('should pad single digits', () => {
      expect(generator.generateFeedbackItemId(0)).toBe('FB-001');
    });

    it('should pad double digits', () => {
      expect(generator.generateFeedbackItemId(9)).toBe('FB-010');
    });

    it('should handle triple digits', () => {
      expect(generator.generateFeedbackItemId(99)).toBe('FB-100');
      expect(generator.generateFeedbackItemId(999)).toBe('FB-1000');
    });
  });
});
