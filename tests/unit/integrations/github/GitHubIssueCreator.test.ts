/**
 * Tests for GitHub Issues Integration
 *
 * Tests markdown parsing, issue formatting, label management,
 * dry-run mode, auth resolution, and API error handling.
 */

import { describe, it, expect, vi, beforeEach, afterEach } from 'vitest';
import * as fsp from 'fs/promises';
import {
  parseMarkuprReport,
  formatIssueBody,
  getLabelsForItem,
  collectRequiredLabels,
  resolveAuth,
  parseRepoString,
  pushToGitHub,
  GitHubAPIClient,
} from '../../../../src/integrations/github/GitHubIssueCreator';
import {
  CATEGORY_LABELS,
  SEVERITY_LABELS,
  MARKUPR_LABEL,
} from '../../../../src/integrations/github/types';
import type { ParsedFeedbackItem } from '../../../../src/integrations/github/types';

vi.mock('fs/promises', async (importOriginal) => {
  const actual = await importOriginal<typeof import('fs/promises')>();
  return { ...actual, readFile: vi.fn() };
});

// ============================================================================
// Test fixtures
// ============================================================================

const SAMPLE_REPORT = `# MyApp Feedback Report
> Generated by markupR on Feb 14, 2026 at 10:30 AM
> Duration: 5:30 | Items: 3 | Screenshots: 4

## Session Overview
- **Session ID:** \`session-123\`
- **Source:** markupR Session (screen)
- **Platform:** darwin
- **Segments:** 3
- **High-impact items:** 2

---

## Executive Summary

- 3 total feedback items were captured.
- 2 items are categorized as **Critical** or **High** priority.
- 4 screenshots were aligned to spoken context.

---

## Actionable Feedback

### FB-001: The login button doesn't work
- **Severity:** Critical
- **Type:** Bug
- **Timestamp:** 00:15

#### What Happened

> The login button doesn't work when I click it. Nothing happens at all.

#### Evidence
![FB-001](screenshots/fb-001.png)

#### Suggested Next Step
- Reproduce and patch this defect, then add a regression test.

---

### FB-002: The dashboard loads slowly
- **Severity:** High
- **Type:** Performance
- **Timestamp:** 01:42

#### What Happened

> The dashboard loads really slowly, takes about 5 seconds.

#### Evidence
![FB-002-1](screenshots/fb-002-1.png)

![FB-002-2](screenshots/fb-002-2.png)

#### Suggested Next Step
- Profile this flow, target the slow step first.

---

### FB-003: Should add dark mode
- **Severity:** Low
- **Type:** Suggestion
- **Timestamp:** 03:20

#### What Happened

> It would be nice if the app had a dark mode option.

#### Evidence
_No screenshot captured for this item._

#### Suggested Next Step
- Track this as an enhancement request and prioritize against current sprint goals.

---

## Summary

| Type | Count |
|------|-------|
| Bug | 1 |
| Performance | 1 |
| Suggestion | 1 |
| **Total** | **3** |
`;

const EMPTY_REPORT = `# MyApp Feedback Report
> Generated by markupR on Feb 14, 2026 at 10:30 AM
> Duration: 0:00

_No feedback items were captured during this session._

---
*Generated by [markupR](https://markupr.com)*
`;

function makeFeedbackItem(overrides: Partial<ParsedFeedbackItem> = {}): ParsedFeedbackItem {
  return {
    id: 'FB-001',
    title: 'Test issue title',
    category: 'Bug',
    severity: 'High',
    timestamp: '00:15',
    transcription: 'The button is broken and nothing happens when clicked.',
    screenshotPaths: ['screenshots/fb-001.png'],
    suggestedAction: 'Fix the button click handler.',
    ...overrides,
  };
}

// ============================================================================
// parseMarkuprReport
// ============================================================================

describe('parseMarkuprReport', () => {
  it('parses all feedback items from a standard report', () => {
    const items = parseMarkuprReport(SAMPLE_REPORT);
    expect(items).toHaveLength(3);
  });

  it('extracts correct IDs', () => {
    const items = parseMarkuprReport(SAMPLE_REPORT);
    expect(items.map(i => i.id)).toEqual(['FB-001', 'FB-002', 'FB-003']);
  });

  it('extracts correct titles', () => {
    const items = parseMarkuprReport(SAMPLE_REPORT);
    expect(items[0].title).toBe("The login button doesn't work");
    expect(items[1].title).toBe('The dashboard loads slowly');
    expect(items[2].title).toBe('Should add dark mode');
  });

  it('extracts correct categories', () => {
    const items = parseMarkuprReport(SAMPLE_REPORT);
    expect(items[0].category).toBe('Bug');
    expect(items[1].category).toBe('Performance');
    expect(items[2].category).toBe('Suggestion');
  });

  it('extracts correct severities', () => {
    const items = parseMarkuprReport(SAMPLE_REPORT);
    expect(items[0].severity).toBe('Critical');
    expect(items[1].severity).toBe('High');
    expect(items[2].severity).toBe('Low');
  });

  it('extracts timestamps', () => {
    const items = parseMarkuprReport(SAMPLE_REPORT);
    expect(items[0].timestamp).toBe('00:15');
    expect(items[1].timestamp).toBe('01:42');
    expect(items[2].timestamp).toBe('03:20');
  });

  it('extracts transcriptions', () => {
    const items = parseMarkuprReport(SAMPLE_REPORT);
    expect(items[0].transcription).toContain("login button doesn't work");
    expect(items[1].transcription).toContain('dashboard loads really slowly');
    expect(items[2].transcription).toContain('dark mode');
  });

  it('extracts screenshot paths', () => {
    const items = parseMarkuprReport(SAMPLE_REPORT);
    expect(items[0].screenshotPaths).toEqual(['screenshots/fb-001.png']);
    expect(items[1].screenshotPaths).toEqual(['screenshots/fb-002-1.png', 'screenshots/fb-002-2.png']);
    expect(items[2].screenshotPaths).toEqual([]);
  });

  it('extracts suggested actions', () => {
    const items = parseMarkuprReport(SAMPLE_REPORT);
    expect(items[0].suggestedAction).toContain('Reproduce and patch');
    expect(items[1].suggestedAction).toContain('Profile this flow');
  });

  it('returns empty array for reports with no feedback items', () => {
    const items = parseMarkuprReport(EMPTY_REPORT);
    expect(items).toHaveLength(0);
  });

  it('returns empty array for empty string', () => {
    const items = parseMarkuprReport('');
    expect(items).toHaveLength(0);
  });

  it('handles reports with a single item', () => {
    const singleItemReport = `# Report
### FB-001: Only item
- **Severity:** Medium
- **Type:** General
- **Timestamp:** 00:00

#### What Happened

> Some text here.

#### Evidence
_No screenshot captured for this item._

#### Suggested Next Step
- Do something.

---
`;
    const items = parseMarkuprReport(singleItemReport);
    expect(items).toHaveLength(1);
    expect(items[0].id).toBe('FB-001');
    expect(items[0].category).toBe('General');
  });
});

// ============================================================================
// formatIssueBody
// ============================================================================

describe('formatIssueBody', () => {
  it('includes item ID and title', () => {
    const item = makeFeedbackItem();
    const body = formatIssueBody(item);
    expect(body).toContain('## FB-001: Test issue title');
  });

  it('includes metadata table', () => {
    const item = makeFeedbackItem({ severity: 'Critical', category: 'Bug' });
    const body = formatIssueBody(item);
    expect(body).toContain('| **Severity** | Critical |');
    expect(body).toContain('| **Category** | Bug |');
  });

  it('includes transcription as blockquote', () => {
    const item = makeFeedbackItem({ transcription: 'Button is broken' });
    const body = formatIssueBody(item);
    expect(body).toContain('> Button is broken');
  });

  it('includes screenshot count when screenshots exist', () => {
    const item = makeFeedbackItem({ screenshotPaths: ['a.png', 'b.png'] });
    const body = formatIssueBody(item);
    expect(body).toContain('2 screenshot(s) captured');
  });

  it('omits screenshots section when no screenshots', () => {
    const item = makeFeedbackItem({ screenshotPaths: [] });
    const body = formatIssueBody(item);
    expect(body).not.toContain('### Screenshots');
  });

  it('includes suggested action when present', () => {
    const item = makeFeedbackItem({ suggestedAction: 'Fix the bug ASAP' });
    const body = formatIssueBody(item);
    expect(body).toContain('Fix the bug ASAP');
  });

  it('includes report path when provided', () => {
    const item = makeFeedbackItem();
    const body = formatIssueBody(item, '/path/to/report.md');
    expect(body).toContain('`/path/to/report.md`');
  });

  it('includes markupR attribution', () => {
    const item = makeFeedbackItem();
    const body = formatIssueBody(item);
    expect(body).toContain('markupR');
  });
});

// ============================================================================
// getLabelsForItem
// ============================================================================

describe('getLabelsForItem', () => {
  it('always includes markupR label', () => {
    const item = makeFeedbackItem();
    const labels = getLabelsForItem(item);
    expect(labels).toContain('markupR');
  });

  it('includes category label for Bug', () => {
    const item = makeFeedbackItem({ category: 'Bug' });
    const labels = getLabelsForItem(item);
    expect(labels).toContain('bug');
  });

  it('includes category label for Suggestion', () => {
    const item = makeFeedbackItem({ category: 'Suggestion' });
    const labels = getLabelsForItem(item);
    expect(labels).toContain('enhancement');
  });

  it('includes category label for Performance', () => {
    const item = makeFeedbackItem({ category: 'Performance' });
    const labels = getLabelsForItem(item);
    expect(labels).toContain('performance');
  });

  it('includes category label for Question', () => {
    const item = makeFeedbackItem({ category: 'Question' });
    const labels = getLabelsForItem(item);
    expect(labels).toContain('question');
  });

  it('includes severity label', () => {
    const item = makeFeedbackItem({ severity: 'Critical' });
    const labels = getLabelsForItem(item);
    expect(labels).toContain('priority: critical');
  });

  it('returns exactly 3 labels (markupR + category + severity)', () => {
    const item = makeFeedbackItem({ category: 'Bug', severity: 'High' });
    const labels = getLabelsForItem(item);
    expect(labels).toHaveLength(3);
    expect(labels).toEqual(['markupR', 'bug', 'priority: high']);
  });
});

// ============================================================================
// collectRequiredLabels
// ============================================================================

describe('collectRequiredLabels', () => {
  it('always includes markupR label', () => {
    const labels = collectRequiredLabels([]);
    expect(labels).toHaveLength(1);
    expect(labels[0].name).toBe('markupR');
  });

  it('deduplicates labels across items', () => {
    const items = [
      makeFeedbackItem({ category: 'Bug', severity: 'High' }),
      makeFeedbackItem({ id: 'FB-002', category: 'Bug', severity: 'High' }),
    ];
    const labels = collectRequiredLabels(items);
    const names = labels.map(l => l.name);
    // markupR, bug, priority: high -- no duplicates
    expect(names).toEqual(['markupR', 'bug', 'priority: high']);
  });

  it('includes all unique categories and severities', () => {
    const items = [
      makeFeedbackItem({ category: 'Bug', severity: 'Critical' }),
      makeFeedbackItem({ id: 'FB-002', category: 'Suggestion', severity: 'Low' }),
    ];
    const labels = collectRequiredLabels(items);
    const names = labels.map(l => l.name);
    expect(names).toContain('bug');
    expect(names).toContain('enhancement');
    expect(names).toContain('priority: critical');
    expect(names).toContain('priority: low');
  });

  it('includes color and description for each label', () => {
    const items = [makeFeedbackItem({ category: 'Bug', severity: 'High' })];
    const labels = collectRequiredLabels(items);
    for (const label of labels) {
      expect(label.color).toBeTruthy();
      expect(label.description).toBeTruthy();
    }
  });
});

// ============================================================================
// parseRepoString
// ============================================================================

describe('parseRepoString', () => {
  it('parses valid owner/repo format', () => {
    const repo = parseRepoString('octocat/hello-world');
    expect(repo).toEqual({ owner: 'octocat', repo: 'hello-world' });
  });

  it('throws on invalid format — no slash', () => {
    expect(() => parseRepoString('invalid')).toThrow('Invalid repository format');
  });

  it('throws on invalid format — too many slashes', () => {
    expect(() => parseRepoString('a/b/c')).toThrow('Invalid repository format');
  });

  it('throws on empty owner', () => {
    expect(() => parseRepoString('/repo')).toThrow('Invalid repository format');
  });

  it('throws on empty repo', () => {
    expect(() => parseRepoString('owner/')).toThrow('Invalid repository format');
  });

  it('throws on empty string', () => {
    expect(() => parseRepoString('')).toThrow('Invalid repository format');
  });
});

// ============================================================================
// resolveAuth
// ============================================================================

describe('resolveAuth', () => {
  const originalEnv = process.env.GITHUB_TOKEN;

  afterEach(() => {
    if (originalEnv !== undefined) {
      process.env.GITHUB_TOKEN = originalEnv;
    } else {
      delete process.env.GITHUB_TOKEN;
    }
  });

  it('prefers explicit token over everything', async () => {
    process.env.GITHUB_TOKEN = 'env-token';
    const auth = await resolveAuth('explicit-token');
    expect(auth.token).toBe('explicit-token');
    expect(auth.source).toBe('flag');
  });

  it('falls back to GITHUB_TOKEN env var', async () => {
    process.env.GITHUB_TOKEN = 'env-token';
    const auth = await resolveAuth(undefined);
    expect(auth.token).toBe('env-token');
    expect(auth.source).toBe('env');
  });

  it('falls back to gh CLI when available', async () => {
    delete process.env.GITHUB_TOKEN;
    // If gh CLI is installed and authenticated, it should resolve with gh-cli source.
    // If not, it should throw. We test both cases.
    try {
      const auth = await resolveAuth(undefined);
      expect(auth.source).toBe('gh-cli');
      expect(auth.token).toBeTruthy();
    } catch (err) {
      expect((err as Error).message).toContain('No GitHub token found');
    }
  });
});

// ============================================================================
// GitHubAPIClient
// ============================================================================

describe('GitHubAPIClient', () => {
  let fetchMock: ReturnType<typeof vi.fn>;

  beforeEach(() => {
    fetchMock = vi.fn();
    vi.stubGlobal('fetch', fetchMock);
  });

  afterEach(() => {
    vi.unstubAllGlobals();
  });

  const auth = { token: 'test-token', source: 'flag' as const };
  const repo = { owner: 'octocat', repo: 'hello-world' };

  describe('createIssue', () => {
    it('sends correct request and returns issue data', async () => {
      fetchMock.mockResolvedValueOnce({
        ok: true,
        json: async () => ({
          number: 42,
          html_url: 'https://github.com/octocat/hello-world/issues/42',
          title: '[FB-001] Test issue',
        }),
      });

      const client = new GitHubAPIClient(auth);
      const result = await client.createIssue(repo, {
        title: '[FB-001] Test issue',
        body: 'Test body',
        labels: ['bug', 'markupR'],
      });

      expect(result.number).toBe(42);
      expect(result.url).toBe('https://github.com/octocat/hello-world/issues/42');

      // Verify fetch was called correctly
      expect(fetchMock).toHaveBeenCalledWith(
        'https://api.github.com/repos/octocat/hello-world/issues',
        expect.objectContaining({
          method: 'POST',
          headers: expect.objectContaining({
            Authorization: 'Bearer test-token',
          }),
        }),
      );

      const body = JSON.parse(fetchMock.mock.calls[0][1].body);
      expect(body.title).toBe('[FB-001] Test issue');
      expect(body.labels).toEqual(['bug', 'markupR']);
    });

    it('throws on API error', async () => {
      fetchMock.mockResolvedValueOnce({
        ok: false,
        status: 403,
        text: async () => 'Forbidden',
      });

      const client = new GitHubAPIClient(auth);
      await expect(
        client.createIssue(repo, { title: 'Test', body: 'Body', labels: [] }),
      ).rejects.toThrow('GitHub API error (403)');
    });
  });

  describe('ensureLabel', () => {
    it('returns false if label already exists', async () => {
      fetchMock.mockResolvedValueOnce({ ok: true }); // GET check succeeds

      const client = new GitHubAPIClient(auth);
      const created = await client.ensureLabel(repo, MARKUPR_LABEL);
      expect(created).toBe(false);
    });

    it('creates label if it does not exist', async () => {
      fetchMock
        .mockResolvedValueOnce({ ok: false, status: 404 }) // GET check fails
        .mockResolvedValueOnce({ ok: true }); // POST create succeeds

      const client = new GitHubAPIClient(auth);
      const created = await client.ensureLabel(repo, MARKUPR_LABEL);
      expect(created).toBe(true);

      // Verify create call
      expect(fetchMock).toHaveBeenCalledTimes(2);
      const createBody = JSON.parse(fetchMock.mock.calls[1][1].body);
      expect(createBody.name).toBe('markupR');
      expect(createBody.color).toBe('6f42c1');
    });

    it('handles 422 race condition gracefully', async () => {
      fetchMock
        .mockResolvedValueOnce({ ok: false, status: 404 }) // GET check fails
        .mockResolvedValueOnce({ ok: false, status: 422, text: async () => 'Already exists' }); // POST 422

      const client = new GitHubAPIClient(auth);
      const created = await client.ensureLabel(repo, MARKUPR_LABEL);
      expect(created).toBe(false); // treated as already existing
    });
  });

  describe('verifyAccess', () => {
    it('succeeds for accessible repos', async () => {
      fetchMock.mockResolvedValueOnce({ ok: true });

      const client = new GitHubAPIClient(auth);
      await expect(client.verifyAccess(repo)).resolves.toBeUndefined();
    });

    it('throws on 404 (repo not found)', async () => {
      fetchMock.mockResolvedValueOnce({ ok: false, status: 404 });

      const client = new GitHubAPIClient(auth);
      await expect(client.verifyAccess(repo)).rejects.toThrow('not found');
    });

    it('throws on 401 (bad token)', async () => {
      fetchMock.mockResolvedValueOnce({ ok: false, status: 401 });

      const client = new GitHubAPIClient(auth);
      await expect(client.verifyAccess(repo)).rejects.toThrow('invalid or expired');
    });
  });
});

// ============================================================================
// pushToGitHub (integration)
// ============================================================================

describe('pushToGitHub', () => {
  let fetchMock: ReturnType<typeof vi.fn>;
  const mockReadFile = fsp.readFile as ReturnType<typeof vi.fn>;

  beforeEach(() => {
    fetchMock = vi.fn();
    vi.stubGlobal('fetch', fetchMock);
    mockReadFile.mockReset();
  });

  afterEach(() => {
    vi.unstubAllGlobals();
  });

  const auth = { token: 'test-token', source: 'flag' as const };
  const repo = { owner: 'octocat', repo: 'hello-world' };

  it('dry-run returns issues without making API calls', async () => {
    mockReadFile.mockResolvedValue(SAMPLE_REPORT);

    const result = await pushToGitHub({
      repo,
      auth,
      reportPath: '/fake/report.md',
      dryRun: true,
    });

    expect(result.dryRun).toBe(true);
    expect(result.created).toHaveLength(3);
    expect(result.created[0].title).toContain('FB-001');
    expect(result.created[1].title).toContain('FB-002');
    expect(result.created[2].title).toContain('FB-003');
    expect(result.labelsCreated.length).toBeGreaterThan(0);
    expect(result.labelsCreated).toContain('markupR');

    // No fetch calls in dry-run mode
    expect(fetchMock).not.toHaveBeenCalled();
  });

  it('dry-run filters to specific items', async () => {
    mockReadFile.mockResolvedValue(SAMPLE_REPORT);

    const result = await pushToGitHub({
      repo,
      auth,
      reportPath: '/fake/report.md',
      dryRun: true,
      items: ['FB-001', 'FB-003'],
    });

    expect(result.created).toHaveLength(2);
    expect(result.created[0].title).toContain('FB-001');
    expect(result.created[1].title).toContain('FB-003');
  });

  it('throws on empty report', async () => {
    mockReadFile.mockResolvedValue(EMPTY_REPORT);

    await expect(
      pushToGitHub({ repo, auth, reportPath: '/fake/empty.md', dryRun: true }),
    ).rejects.toThrow('No feedback items found');
  });

  it('throws when filtered items not found', async () => {
    mockReadFile.mockResolvedValue(SAMPLE_REPORT);

    await expect(
      pushToGitHub({
        repo,
        auth,
        reportPath: '/fake/report.md',
        dryRun: true,
        items: ['FB-999'],
      }),
    ).rejects.toThrow('None of the specified items');
  });

  it('creates issues in real mode with correct API calls', async () => {
    mockReadFile.mockResolvedValue(SAMPLE_REPORT);

    // verifyAccess
    fetchMock.mockResolvedValueOnce({ ok: true });

    // ensureLabel calls (markupR + bug + performance + enhancement + critical + high + low)
    // Each label: GET check — pretend all already exist
    for (let i = 0; i < 7; i++) {
      fetchMock.mockResolvedValueOnce({ ok: true });
    }

    // createIssue calls (3 items)
    for (let i = 1; i <= 3; i++) {
      fetchMock.mockResolvedValueOnce({
        ok: true,
        json: async () => ({
          number: i,
          html_url: `https://github.com/octocat/hello-world/issues/${i}`,
          title: `[FB-00${i}] Test`,
        }),
      });
    }

    const result = await pushToGitHub({
      repo,
      auth,
      reportPath: '/fake/report.md',
      dryRun: false,
    });

    expect(result.dryRun).toBe(false);
    expect(result.created).toHaveLength(3);
    expect(result.created[0].number).toBe(1);
    expect(result.created[1].number).toBe(2);
    expect(result.created[2].number).toBe(3);
    expect(result.errors).toHaveLength(0);
  });

  it('handles partial failures gracefully', async () => {
    mockReadFile.mockResolvedValue(SAMPLE_REPORT);

    // verifyAccess
    fetchMock.mockResolvedValueOnce({ ok: true });

    // Labels all exist
    for (let i = 0; i < 7; i++) {
      fetchMock.mockResolvedValueOnce({ ok: true });
    }

    // First issue succeeds
    fetchMock.mockResolvedValueOnce({
      ok: true,
      json: async () => ({
        number: 1,
        html_url: 'https://github.com/octocat/hello-world/issues/1',
        title: '[FB-001] Test',
      }),
    });

    // Second issue fails
    fetchMock.mockResolvedValueOnce({
      ok: false,
      status: 500,
      text: async () => 'Internal Server Error',
    });

    // Third issue succeeds
    fetchMock.mockResolvedValueOnce({
      ok: true,
      json: async () => ({
        number: 3,
        html_url: 'https://github.com/octocat/hello-world/issues/3',
        title: '[FB-003] Test',
      }),
    });

    const result = await pushToGitHub({
      repo,
      auth,
      reportPath: '/fake/report.md',
      dryRun: false,
    });

    expect(result.created).toHaveLength(2);
    expect(result.errors).toHaveLength(1);
    expect(result.errors[0].itemId).toBe('FB-002');
  });
});

// ============================================================================
// CATEGORY_LABELS and SEVERITY_LABELS constants
// ============================================================================

describe('label constants', () => {
  it('CATEGORY_LABELS covers all categories', () => {
    const expected = ['Bug', 'UX Issue', 'Suggestion', 'Performance', 'Question', 'General'];
    for (const cat of expected) {
      expect(CATEGORY_LABELS[cat as keyof typeof CATEGORY_LABELS]).toBeDefined();
    }
  });

  it('SEVERITY_LABELS covers all severities', () => {
    const expected = ['Critical', 'High', 'Medium', 'Low'];
    for (const sev of expected) {
      expect(SEVERITY_LABELS[sev as keyof typeof SEVERITY_LABELS]).toBeDefined();
    }
  });

  it('all labels have valid 6-char hex colors', () => {
    const allLabels = [
      ...Object.values(CATEGORY_LABELS),
      ...Object.values(SEVERITY_LABELS),
      MARKUPR_LABEL,
    ];
    for (const label of allLabels) {
      expect(label.color).toMatch(/^[0-9a-f]{6}$/);
    }
  });
});
