/**
 * LinearIssueCreator Unit Tests
 *
 * Tests:
 * - Markdown report parsing (parseMarkdownReport)
 * - Priority mapping (severity → Linear priority)
 * - Label mapping (category → Linear label name)
 * - Issue creation via GraphQL API
 * - Team resolution
 * - Dry-run mode
 * - Error handling
 */

import { describe, it, expect, vi, beforeEach } from 'vitest';

// =============================================================================
// Hoisted mocks
// =============================================================================

const { mockReadFile, mockFetch } = vi.hoisted(() => ({
  mockReadFile: vi.fn(),
  mockFetch: vi.fn(),
}));

vi.mock('fs/promises', () => ({
  readFile: mockReadFile,
}));

// Mock global fetch
vi.stubGlobal('fetch', mockFetch);

import {
  LinearIssueCreator,
  parseMarkdownReport,
} from '../../../../src/integrations/linear/LinearIssueCreator';
import {
  SEVERITY_TO_PRIORITY,
  CATEGORY_TO_LABEL,
} from '../../../../src/integrations/linear/types';

// =============================================================================
// Test data
// =============================================================================

const SAMPLE_REPORT = `# MyApp Feedback Report
> Generated by markupr on Feb 14, 2026 at 10:30 AM
> Duration: 5:30 | Items: 3 | Screenshots: 2

## Session Overview
- **Session ID:** \`session-123\`
- **Source:** markupr Session (screen)
- **Platform:** darwin
- **Segments:** 3
- **High-impact items:** 2

---

## Executive Summary

- 3 total feedback items were captured.
- 2 items are categorized as **Critical** or **High** priority.
- 2 screenshots were aligned to spoken context.

---

## Actionable Feedback

### FB-001: Login button is broken
- **Severity:** Critical
- **Type:** Bug
- **Timestamp:** 00:15
- **Signals:** login, broken, error

#### What Happened

> The login button doesn't respond when clicked. It seems completely broken and throws a console error.

#### Evidence
![FB-001](screenshots/fb-001.png)

#### Suggested Next Step
- Reproduce and patch this defect, then add a regression test.

---

### FB-002: Navigation is confusing
- **Severity:** High
- **Type:** UX Issue
- **Timestamp:** 01:30

#### What Happened

> The navigation menu is really confusing. Hard to find settings.

#### Evidence
![FB-002](screenshots/fb-002.png)

#### Suggested Next Step
- Revise the UI interaction and run a quick usability check.

---

### FB-003: Should add dark mode
- **Severity:** Low
- **Type:** Suggestion
- **Timestamp:** 03:45

#### What Happened

> It would be nice if the app had a dark mode option. Should add that.

#### Evidence
_No screenshot captured for this item._

#### Suggested Next Step
- Track this as an enhancement request and prioritize against current sprint goals.

---

## Summary

| Type | Count |
|------|-------|
| Bug | 1 |
| UX Issue | 1 |
| Suggestion | 1 |
| **Total** | **3** |
`;

function mockGraphqlResponse(data: unknown) {
  return {
    ok: true,
    json: async () => ({ data }),
  };
}

function mockGraphqlError(errors: { message: string }[]) {
  return {
    ok: true,
    json: async () => ({ errors }),
  };
}

// =============================================================================
// Tests: parseMarkdownReport
// =============================================================================

describe('parseMarkdownReport', () => {
  it('should parse all feedback items from a report', () => {
    const items = parseMarkdownReport(SAMPLE_REPORT);
    expect(items).toHaveLength(3);
  });

  it('should extract item IDs', () => {
    const items = parseMarkdownReport(SAMPLE_REPORT);
    expect(items[0].id).toBe('FB-001');
    expect(items[1].id).toBe('FB-002');
    expect(items[2].id).toBe('FB-003');
  });

  it('should extract titles', () => {
    const items = parseMarkdownReport(SAMPLE_REPORT);
    expect(items[0].title).toBe('Login button is broken');
    expect(items[1].title).toBe('Navigation is confusing');
    expect(items[2].title).toBe('Should add dark mode');
  });

  it('should extract severity levels', () => {
    const items = parseMarkdownReport(SAMPLE_REPORT);
    expect(items[0].severity).toBe('Critical');
    expect(items[1].severity).toBe('High');
    expect(items[2].severity).toBe('Low');
  });

  it('should extract categories', () => {
    const items = parseMarkdownReport(SAMPLE_REPORT);
    expect(items[0].category).toBe('Bug');
    expect(items[1].category).toBe('UX Issue');
    expect(items[2].category).toBe('Suggestion');
  });

  it('should extract timestamps', () => {
    const items = parseMarkdownReport(SAMPLE_REPORT);
    expect(items[0].timestamp).toBe('00:15');
    expect(items[1].timestamp).toBe('01:30');
    expect(items[2].timestamp).toBe('03:45');
  });

  it('should extract descriptions from blockquotes', () => {
    const items = parseMarkdownReport(SAMPLE_REPORT);
    expect(items[0].description).toContain('login button');
    expect(items[1].description).toContain('navigation menu');
    expect(items[2].description).toContain('dark mode');
  });

  it('should extract screenshot paths', () => {
    const items = parseMarkdownReport(SAMPLE_REPORT);
    expect(items[0].screenshotPaths).toEqual(['screenshots/fb-001.png']);
    expect(items[1].screenshotPaths).toEqual(['screenshots/fb-002.png']);
    expect(items[2].screenshotPaths).toEqual([]);
  });

  it('should extract suggested actions', () => {
    const items = parseMarkdownReport(SAMPLE_REPORT);
    expect(items[0].suggestedAction).toContain('Reproduce and patch');
    expect(items[1].suggestedAction).toContain('Revise the UI');
  });

  it('should return empty array for reports with no feedback items', () => {
    const emptyReport = `# Empty Report\n\n_No feedback items._\n`;
    const items = parseMarkdownReport(emptyReport);
    expect(items).toHaveLength(0);
  });

  it('should handle reports with a single item', () => {
    const singleItemReport = `# Report

### FB-001: Single item
- **Severity:** Medium
- **Type:** General
- **Timestamp:** 00:00

#### What Happened

> Just one item here.

#### Evidence
_No screenshot captured for this item._

#### Suggested Next Step
- Investigate this item.
`;
    const items = parseMarkdownReport(singleItemReport);
    expect(items).toHaveLength(1);
    expect(items[0].id).toBe('FB-001');
    expect(items[0].severity).toBe('Medium');
    expect(items[0].category).toBe('General');
  });
});

// =============================================================================
// Tests: Priority mapping
// =============================================================================

describe('SEVERITY_TO_PRIORITY', () => {
  it('should map Critical to Urgent (1)', () => {
    expect(SEVERITY_TO_PRIORITY.Critical).toBe(1);
  });

  it('should map High to High (2)', () => {
    expect(SEVERITY_TO_PRIORITY.High).toBe(2);
  });

  it('should map Medium to Medium (3)', () => {
    expect(SEVERITY_TO_PRIORITY.Medium).toBe(3);
  });

  it('should map Low to Low (4)', () => {
    expect(SEVERITY_TO_PRIORITY.Low).toBe(4);
  });
});

// =============================================================================
// Tests: Label mapping
// =============================================================================

describe('CATEGORY_TO_LABEL', () => {
  it('should map Bug to Bug', () => {
    expect(CATEGORY_TO_LABEL['Bug']).toBe('Bug');
  });

  it('should map UX Issue to Improvement', () => {
    expect(CATEGORY_TO_LABEL['UX Issue']).toBe('Improvement');
  });

  it('should map Suggestion to Feature', () => {
    expect(CATEGORY_TO_LABEL['Suggestion']).toBe('Feature');
  });

  it('should map Performance to Bug', () => {
    expect(CATEGORY_TO_LABEL['Performance']).toBe('Bug');
  });
});

// =============================================================================
// Tests: LinearIssueCreator
// =============================================================================

describe('LinearIssueCreator', () => {
  let creator: LinearIssueCreator;

  beforeEach(() => {
    vi.clearAllMocks();
    creator = new LinearIssueCreator('lin_api_test_token');
  });

  describe('resolveTeam', () => {
    it('should resolve a team by key', async () => {
      mockFetch.mockResolvedValueOnce(
        mockGraphqlResponse({
          teams: {
            nodes: [
              { id: 'team-1', key: 'ENG', name: 'Engineering' },
              { id: 'team-2', key: 'DES', name: 'Design' },
            ],
          },
        }),
      );

      const team = await creator.resolveTeam('ENG');
      expect(team.id).toBe('team-1');
      expect(team.key).toBe('ENG');
      expect(team.name).toBe('Engineering');
    });

    it('should resolve team key case-insensitively', async () => {
      mockFetch.mockResolvedValueOnce(
        mockGraphqlResponse({
          teams: {
            nodes: [{ id: 'team-1', key: 'ENG', name: 'Engineering' }],
          },
        }),
      );

      const team = await creator.resolveTeam('eng');
      expect(team.id).toBe('team-1');
    });

    it('should throw when team not found', async () => {
      mockFetch.mockResolvedValueOnce(
        mockGraphqlResponse({
          teams: {
            nodes: [{ id: 'team-1', key: 'ENG', name: 'Engineering' }],
          },
        }),
      );

      await expect(creator.resolveTeam('MISSING')).rejects.toThrow(
        'Team "MISSING" not found',
      );
    });
  });

  describe('getTeamLabels', () => {
    it('should return labels for a team', async () => {
      mockFetch.mockResolvedValueOnce(
        mockGraphqlResponse({
          team: {
            labels: {
              nodes: [
                { id: 'label-1', name: 'Bug' },
                { id: 'label-2', name: 'Feature' },
              ],
            },
          },
        }),
      );

      const labels = await creator.getTeamLabels('team-1');
      expect(labels).toHaveLength(2);
      expect(labels[0].name).toBe('Bug');
    });
  });

  describe('createIssue', () => {
    it('should create an issue successfully', async () => {
      mockFetch.mockResolvedValueOnce(
        mockGraphqlResponse({
          issueCreate: {
            success: true,
            issue: {
              id: 'issue-1',
              url: 'https://linear.app/team/ENG-1',
              identifier: 'ENG-1',
            },
          },
        }),
      );

      const result = await creator.createIssue({
        title: 'Test issue',
        description: 'Test description',
        teamId: 'team-1',
        priority: 2,
      });

      expect(result.success).toBe(true);
      expect(result.issueId).toBe('issue-1');
      expect(result.issueUrl).toBe('https://linear.app/team/ENG-1');
      expect(result.identifier).toBe('ENG-1');
    });

    it('should handle API error', async () => {
      mockFetch.mockResolvedValueOnce(
        mockGraphqlError([{ message: 'Unauthorized' }]),
      );

      const result = await creator.createIssue({
        title: 'Test',
        description: 'Test',
        teamId: 'team-1',
        priority: 3,
      });

      expect(result.success).toBe(false);
      expect(result.error).toContain('Unauthorized');
    });

    it('should handle HTTP error', async () => {
      mockFetch.mockResolvedValueOnce({
        ok: false,
        status: 500,
        statusText: 'Internal Server Error',
      });

      const result = await creator.createIssue({
        title: 'Test',
        description: 'Test',
        teamId: 'team-1',
        priority: 3,
      });

      expect(result.success).toBe(false);
      expect(result.error).toContain('500');
    });

    it('should include label IDs when provided', async () => {
      mockFetch.mockResolvedValueOnce(
        mockGraphqlResponse({
          issueCreate: {
            success: true,
            issue: {
              id: 'issue-1',
              url: 'https://linear.app/team/ENG-1',
              identifier: 'ENG-1',
            },
          },
        }),
      );

      await creator.createIssue({
        title: 'Test',
        description: 'Test',
        teamId: 'team-1',
        priority: 2,
        labelIds: ['label-1'],
      });

      const body = JSON.parse(mockFetch.mock.calls[0][1].body);
      expect(body.variables.input.labelIds).toEqual(['label-1']);
    });

    it('should include project ID when provided', async () => {
      mockFetch.mockResolvedValueOnce(
        mockGraphqlResponse({
          issueCreate: {
            success: true,
            issue: {
              id: 'issue-1',
              url: 'https://linear.app/team/ENG-1',
              identifier: 'ENG-1',
            },
          },
        }),
      );

      await creator.createIssue({
        title: 'Test',
        description: 'Test',
        teamId: 'team-1',
        priority: 2,
        projectId: 'project-1',
      });

      const body = JSON.parse(mockFetch.mock.calls[0][1].body);
      expect(body.variables.input.projectId).toBe('project-1');
    });

    it('should send correct auth header', async () => {
      mockFetch.mockResolvedValueOnce(
        mockGraphqlResponse({
          issueCreate: {
            success: true,
            issue: { id: '1', url: 'u', identifier: 'i' },
          },
        }),
      );

      await creator.createIssue({
        title: 'Test',
        description: 'Test',
        teamId: 'team-1',
        priority: 3,
      });

      expect(mockFetch.mock.calls[0][1].headers.Authorization).toBe(
        'lin_api_test_token',
      );
    });
  });

  describe('pushReport', () => {
    const setupMocksForPush = () => {
      // readFile returns sample report
      mockReadFile.mockResolvedValueOnce(SAMPLE_REPORT);

      // resolveTeam
      mockFetch.mockResolvedValueOnce(
        mockGraphqlResponse({
          teams: {
            nodes: [{ id: 'team-1', key: 'ENG', name: 'Engineering' }],
          },
        }),
      );

      // getTeamLabels
      mockFetch.mockResolvedValueOnce(
        mockGraphqlResponse({
          team: {
            labels: {
              nodes: [
                { id: 'label-bug', name: 'Bug' },
                { id: 'label-imp', name: 'Improvement' },
                { id: 'label-feat', name: 'Feature' },
              ],
            },
          },
        }),
      );
    };

    it('should create issues for all items in a report', async () => {
      setupMocksForPush();

      // 3 issue creations
      for (let i = 0; i < 3; i++) {
        mockFetch.mockResolvedValueOnce(
          mockGraphqlResponse({
            issueCreate: {
              success: true,
              issue: {
                id: `issue-${i}`,
                url: `https://linear.app/team/ENG-${i + 1}`,
                identifier: `ENG-${i + 1}`,
              },
            },
          }),
        );
      }

      const result = await creator.pushReport('/path/to/report.md', {
        token: 'lin_api_test_token',
        teamKey: 'ENG',
      });

      expect(result.totalItems).toBe(3);
      expect(result.created).toBe(3);
      expect(result.failed).toBe(0);
      expect(result.issues).toHaveLength(3);
    });

    it('should handle dry-run mode', async () => {
      setupMocksForPush();

      const result = await creator.pushReport('/path/to/report.md', {
        token: 'lin_api_test_token',
        teamKey: 'ENG',
        dryRun: true,
      });

      expect(result.dryRun).toBe(true);
      expect(result.totalItems).toBe(3);
      expect(result.created).toBe(3);
      expect(result.failed).toBe(0);
      // No issue creation calls after team + labels (2 calls)
      expect(mockFetch).toHaveBeenCalledTimes(2);
    });

    it('should map Bug category to Bug label', async () => {
      setupMocksForPush();

      // 3 issue creations
      for (let i = 0; i < 3; i++) {
        mockFetch.mockResolvedValueOnce(
          mockGraphqlResponse({
            issueCreate: {
              success: true,
              issue: {
                id: `issue-${i}`,
                url: `url-${i}`,
                identifier: `ENG-${i}`,
              },
            },
          }),
        );
      }

      await creator.pushReport('/path/to/report.md', {
        token: 'lin_api_test_token',
        teamKey: 'ENG',
      });

      // First issue (Bug) should get Bug label
      const firstIssueBody = JSON.parse(mockFetch.mock.calls[2][1].body);
      expect(firstIssueBody.variables.input.labelIds).toEqual(['label-bug']);
    });

    it('should map UX Issue category to Improvement label', async () => {
      setupMocksForPush();

      for (let i = 0; i < 3; i++) {
        mockFetch.mockResolvedValueOnce(
          mockGraphqlResponse({
            issueCreate: {
              success: true,
              issue: {
                id: `issue-${i}`,
                url: `url-${i}`,
                identifier: `ENG-${i}`,
              },
            },
          }),
        );
      }

      await creator.pushReport('/path/to/report.md', {
        token: 'lin_api_test_token',
        teamKey: 'ENG',
      });

      // Second issue (UX Issue) should get Improvement label
      const secondIssueBody = JSON.parse(mockFetch.mock.calls[3][1].body);
      expect(secondIssueBody.variables.input.labelIds).toEqual(['label-imp']);
    });

    it('should map Critical severity to priority 1', async () => {
      setupMocksForPush();

      for (let i = 0; i < 3; i++) {
        mockFetch.mockResolvedValueOnce(
          mockGraphqlResponse({
            issueCreate: {
              success: true,
              issue: {
                id: `issue-${i}`,
                url: `url-${i}`,
                identifier: `ENG-${i}`,
              },
            },
          }),
        );
      }

      await creator.pushReport('/path/to/report.md', {
        token: 'lin_api_test_token',
        teamKey: 'ENG',
      });

      // First issue (Critical) should have priority 1
      const firstIssueBody = JSON.parse(mockFetch.mock.calls[2][1].body);
      expect(firstIssueBody.variables.input.priority).toBe(1);
    });

    it('should count failed issues', async () => {
      setupMocksForPush();

      // First issue succeeds
      mockFetch.mockResolvedValueOnce(
        mockGraphqlResponse({
          issueCreate: {
            success: true,
            issue: { id: 'i', url: 'u', identifier: 'ENG-1' },
          },
        }),
      );
      // Second fails
      mockFetch.mockResolvedValueOnce(
        mockGraphqlError([{ message: 'Rate limited' }]),
      );
      // Third succeeds
      mockFetch.mockResolvedValueOnce(
        mockGraphqlResponse({
          issueCreate: {
            success: true,
            issue: { id: 'i', url: 'u', identifier: 'ENG-3' },
          },
        }),
      );

      const result = await creator.pushReport('/path/to/report.md', {
        token: 'lin_api_test_token',
        teamKey: 'ENG',
      });

      expect(result.created).toBe(2);
      expect(result.failed).toBe(1);
    });

    it('should include [FB-XXX] prefix in issue titles', async () => {
      setupMocksForPush();

      for (let i = 0; i < 3; i++) {
        mockFetch.mockResolvedValueOnce(
          mockGraphqlResponse({
            issueCreate: {
              success: true,
              issue: { id: `i${i}`, url: `u${i}`, identifier: `ENG-${i}` },
            },
          }),
        );
      }

      await creator.pushReport('/path/to/report.md', {
        token: 'lin_api_test_token',
        teamKey: 'ENG',
      });

      const firstBody = JSON.parse(mockFetch.mock.calls[2][1].body);
      expect(firstBody.variables.input.title).toBe(
        '[FB-001] Login button is broken',
      );
    });

    it('should include issue description with metadata', async () => {
      setupMocksForPush();

      for (let i = 0; i < 3; i++) {
        mockFetch.mockResolvedValueOnce(
          mockGraphqlResponse({
            issueCreate: {
              success: true,
              issue: { id: `i${i}`, url: `u${i}`, identifier: `ENG-${i}` },
            },
          }),
        );
      }

      await creator.pushReport('/path/to/report.md', {
        token: 'lin_api_test_token',
        teamKey: 'ENG',
      });

      const firstBody = JSON.parse(mockFetch.mock.calls[2][1].body);
      const desc = firstBody.variables.input.description;
      expect(desc).toContain('markupr Feedback: FB-001');
      expect(desc).toContain('**Severity:** Critical');
      expect(desc).toContain('**Category:** Bug');
      expect(desc).toContain('markupr');
    });
  });
});
